"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See LICENSE in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeDockerInspectImageRecord = exports.isDockerInspectImageRecord = void 0;
const dayjs_1 = require("../../utils/dayjs");
const parseDockerLikeImageName_1 = require("../../utils/parseDockerLikeImageName");
const toArray_1 = require("../../utils/toArray");
const parseDockerLikeEnvironmentVariables_1 = require("./parseDockerLikeEnvironmentVariables");
function isDockerInspectImageConfig(maybeImageConfig) {
    const imageConfig = maybeImageConfig;
    if (!imageConfig || typeof imageConfig !== 'object') {
        return false;
    }
    if (imageConfig.Env && !Array.isArray(imageConfig.Env)) {
        return false;
    }
    if (imageConfig.Labels && typeof imageConfig.Labels !== 'object') {
        return false;
    }
    if (imageConfig.ExposedPorts && typeof imageConfig.ExposedPorts !== 'object') {
        return false;
    }
    if (imageConfig.Volumes && typeof imageConfig.Volumes !== 'object') {
        return false;
    }
    if (imageConfig.WorkingDir && typeof imageConfig.WorkingDir !== 'string') {
        return false;
    }
    if (imageConfig.User && typeof imageConfig.User !== 'string') {
        return false;
    }
    if (imageConfig.Entrypoint && !Array.isArray(imageConfig.Entrypoint) && typeof imageConfig.Entrypoint !== 'string') {
        return false;
    }
    if (imageConfig.Cmd && !Array.isArray(imageConfig.Cmd) && typeof imageConfig.Cmd !== 'string') {
        return false;
    }
    return true;
}
function isDockerInspectImageRecord(maybeImage) {
    const image = maybeImage;
    if (!image || typeof image !== 'object') {
        return false;
    }
    if (typeof image.Id !== 'string') {
        return false;
    }
    if (!Array.isArray(image.RepoTags)) {
        return false;
    }
    if (!isDockerInspectImageConfig(image.Config)) {
        return false;
    }
    if (!Array.isArray(image.RepoDigests)) {
        return false;
    }
    if (typeof image.Architecture !== 'string') {
        return false;
    }
    if (typeof image.Os !== 'string') {
        return false;
    }
    if (typeof image.Created !== 'string') {
        return false;
    }
    return true;
}
exports.isDockerInspectImageRecord = isDockerInspectImageRecord;
function normalizeDockerInspectImageRecord(image) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
    // This is effectively doing firstOrDefault on the RepoTags for the image. If there are any values
    // in RepoTags, the first one will be parsed and returned as the tag name for the image.
    const imageNameInfo = (0, parseDockerLikeImageName_1.parseDockerLikeImageName)((_a = image.RepoTags) === null || _a === void 0 ? void 0 : _a[0]);
    // Parse any environment variables defined for the image
    const environmentVariables = (0, parseDockerLikeEnvironmentVariables_1.parseDockerLikeEnvironmentVariables)(((_b = image.Config) === null || _b === void 0 ? void 0 : _b.Env) || []);
    // Parse any default ports exposed by the image
    const ports = Object.entries(((_c = image.Config) === null || _c === void 0 ? void 0 : _c.ExposedPorts) || {}).map(([rawPort]) => {
        const [port, protocol] = rawPort.split('/');
        return {
            containerPort: parseInt(port),
            protocol: protocol.toLowerCase() === 'tcp' ? 'tcp' : protocol.toLowerCase() === 'udp' ? 'udp' : undefined,
        };
    });
    // Parse any default volumes specified by the image
    const volumes = Object.entries(((_d = image.Config) === null || _d === void 0 ? void 0 : _d.Volumes) || {}).map(([rawVolume]) => rawVolume);
    // Parse any labels assigned to the image
    const labels = (_f = (_e = image.Config) === null || _e === void 0 ? void 0 : _e.Labels) !== null && _f !== void 0 ? _f : {};
    // Parse and normalize the image architecture
    const architecture = ((_g = image.Architecture) === null || _g === void 0 ? void 0 : _g.toLowerCase()) === 'amd64'
        ? 'amd64'
        : ((_h = image.Architecture) === null || _h === void 0 ? void 0 : _h.toLowerCase()) === 'arm64' ? 'arm64' : undefined;
    // Parse and normalize the image OS
    const os = ((_j = image.Os) === null || _j === void 0 ? void 0 : _j.toLowerCase()) === 'linux'
        ? 'linux'
        : ((_k = image.Architecture) === null || _k === void 0 ? void 0 : _k.toLowerCase()) === 'windows'
            ? 'windows'
            : undefined;
    // Determine if the image has been pushed to a remote repo
    // (no repo digests or only localhost/ repo digests)
    const isLocalImage = !(image.RepoDigests || []).some((digest) => !digest.toLowerCase().startsWith('localhost/'));
    return {
        id: image.Id,
        image: imageNameInfo,
        repoDigests: image.RepoDigests,
        isLocalImage,
        environmentVariables,
        ports,
        volumes,
        labels,
        entrypoint: (0, toArray_1.toArray)(((_l = image.Config) === null || _l === void 0 ? void 0 : _l.Entrypoint) || []),
        command: (0, toArray_1.toArray)(((_m = image.Config) === null || _m === void 0 ? void 0 : _m.Cmd) || []),
        currentDirectory: ((_o = image.Config) === null || _o === void 0 ? void 0 : _o.WorkingDir) || undefined,
        architecture,
        operatingSystem: os,
        createdAt: (0, dayjs_1.dayjs)(image.Created).toDate(),
        user: ((_p = image.Config) === null || _p === void 0 ? void 0 : _p.User) || undefined,
        raw: JSON.stringify(image),
    };
}
exports.normalizeDockerInspectImageRecord = normalizeDockerInspectImageRecord;
//# sourceMappingURL=DockerInspectImageRecord.js.map