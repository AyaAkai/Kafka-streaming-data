"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See LICENSE in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeDockerInspectContainerRecord = exports.isDockerInspectContainerRecord = void 0;
const dayjs_1 = require("../../utils/dayjs");
const parseDockerLikeImageName_1 = require("../../utils/parseDockerLikeImageName");
const toArray_1 = require("../../utils/toArray");
const parseDockerLikeEnvironmentVariables_1 = require("./parseDockerLikeEnvironmentVariables");
// TODO: Actually test properties
function isDockerInspectContainerRecord(maybeContainer) {
    return true;
}
exports.isDockerInspectContainerRecord = isDockerInspectContainerRecord;
function normalizeDockerInspectContainerRecord(container) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    // Parse the environment variables assigned to the container at runtime
    const environmentVariables = (0, parseDockerLikeEnvironmentVariables_1.parseDockerLikeEnvironmentVariables)(((_a = container.Config) === null || _a === void 0 ? void 0 : _a.Env) || []);
    // Parse the networks assigned to the container and normalize to InspectContainersItemNetwork
    // records
    const networks = Object.entries(((_b = container.NetworkSettings) === null || _b === void 0 ? void 0 : _b.Networks) || {}).map(([name, dockerNetwork]) => {
        return {
            name,
            gateway: dockerNetwork.Gateway || undefined,
            ipAddress: dockerNetwork.IPAddress || undefined,
            macAddress: dockerNetwork.MacAddress || undefined,
        };
    });
    // Parse the exposed ports for the container and normalize to a PortBinding record
    const ports = Object.entries(((_c = container.NetworkSettings) === null || _c === void 0 ? void 0 : _c.Ports) || {}).map(([rawPort, hostBinding]) => {
        var _a, _b;
        const [port, protocol] = rawPort.split('/');
        return {
            hostIp: (_a = hostBinding === null || hostBinding === void 0 ? void 0 : hostBinding[0]) === null || _a === void 0 ? void 0 : _a.HostIp,
            hostPort: (_b = hostBinding === null || hostBinding === void 0 ? void 0 : hostBinding[0]) === null || _b === void 0 ? void 0 : _b.HostPort,
            containerPort: parseInt(port),
            protocol: protocol.toLowerCase() === 'tcp'
                ? 'tcp'
                : protocol.toLowerCase() === 'udp'
                    ? 'udp'
                    : undefined,
        };
    });
    // Parse the volume and bind mounts associated with the given runtime and normalize to
    // InspectContainersItemMount records
    const mounts = (container.Mounts || []).reduce((curMounts, mount) => {
        switch (mount === null || mount === void 0 ? void 0 : mount.Type) {
            case 'bind':
                return [...curMounts, {
                        type: 'bind',
                        source: mount.Source,
                        destination: mount.Destination,
                        readOnly: !mount.RW,
                    }];
            case 'volume':
                return [...curMounts, {
                        type: 'volume',
                        name: mount.Name,
                        source: mount.Source,
                        destination: mount.Destination,
                        driver: mount.Driver,
                        readOnly: !mount.RW,
                    }];
        }
    }, new Array());
    const labels = (_e = (_d = container.Config) === null || _d === void 0 ? void 0 : _d.Labels) !== null && _e !== void 0 ? _e : {};
    const createdAt = dayjs_1.dayjs.utc(container.Created);
    const startedAt = ((_f = container.State) === null || _f === void 0 ? void 0 : _f.StartedAt)
        ? dayjs_1.dayjs.utc((_g = container.State) === null || _g === void 0 ? void 0 : _g.StartedAt)
        : undefined;
    const finishedAt = ((_h = container.State) === null || _h === void 0 ? void 0 : _h.FinishedAt)
        ? dayjs_1.dayjs.utc((_j = container.State) === null || _j === void 0 ? void 0 : _j.FinishedAt)
        : undefined;
    // Return the normalized InspectContainersItem record
    return {
        id: container.Id,
        name: container.Name,
        imageId: container.Image,
        image: (0, parseDockerLikeImageName_1.parseDockerLikeImageName)(container.Config.Image),
        isolation: (_k = container.HostConfig) === null || _k === void 0 ? void 0 : _k.Isolation,
        status: (_l = container.State) === null || _l === void 0 ? void 0 : _l.Status,
        environmentVariables,
        networks,
        ipAddress: ((_m = container.NetworkSettings) === null || _m === void 0 ? void 0 : _m.IPAddress) ? (_o = container.NetworkSettings) === null || _o === void 0 ? void 0 : _o.IPAddress : undefined,
        ports,
        mounts,
        labels,
        entrypoint: (0, toArray_1.toArray)((_q = (_p = container.Config) === null || _p === void 0 ? void 0 : _p.Entrypoint) !== null && _q !== void 0 ? _q : []),
        command: (0, toArray_1.toArray)((_s = (_r = container.Config) === null || _r === void 0 ? void 0 : _r.Cmd) !== null && _s !== void 0 ? _s : []),
        currentDirectory: ((_t = container.Config) === null || _t === void 0 ? void 0 : _t.WorkingDir) || undefined,
        createdAt: createdAt.toDate(),
        startedAt: startedAt && (startedAt.isSame(createdAt) || startedAt.isAfter(createdAt))
            ? startedAt.toDate()
            : undefined,
        finishedAt: finishedAt && (finishedAt.isSame(createdAt) || finishedAt.isAfter(createdAt))
            ? finishedAt.toDate()
            : undefined,
        raw: JSON.stringify(container),
    };
}
exports.normalizeDockerInspectContainerRecord = normalizeDockerInspectContainerRecord;
//# sourceMappingURL=DockerInspectContainerRecord.js.map