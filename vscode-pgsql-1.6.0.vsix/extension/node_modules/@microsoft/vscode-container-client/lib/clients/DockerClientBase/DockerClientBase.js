"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See LICENSE in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.DockerClientBase = void 0;
const readline = require("readline");
const vscode_1 = require("vscode");
const CancellationTokenLike_1 = require("../../typings/CancellationTokenLike");
const CancellationError_1 = require("../../utils/CancellationError");
const CommandNotSupportedError_1 = require("../../utils/CommandNotSupportedError");
const asIds_1 = require("../../utils/asIds");
const commandLineBuilder_1 = require("../../utils/commandLineBuilder");
const dayjs_1 = require("../../utils/dayjs");
const streamToGenerator_1 = require("../../utils/streamToGenerator");
const toArray_1 = require("../../utils/toArray");
const ConfigurableClient_1 = require("../ConfigurableClient");
const DockerEventRecord_1 = require("./DockerEventRecord");
const DockerInfoRecord_1 = require("./DockerInfoRecord");
const DockerInspectContainerRecord_1 = require("./DockerInspectContainerRecord");
const DockerInspectImageRecord_1 = require("./DockerInspectImageRecord");
const DockerInspectNetworkRecord_1 = require("./DockerInspectNetworkRecord");
const DockerInspectVolumeRecord_1 = require("./DockerInspectVolumeRecord");
const DockerListContainerRecord_1 = require("./DockerListContainerRecord");
const DockerListImageRecord_1 = require("./DockerListImageRecord");
const DockerListNetworkRecord_1 = require("./DockerListNetworkRecord");
const DockerVersionRecord_1 = require("./DockerVersionRecord");
const DockerVolumeRecord_1 = require("./DockerVolumeRecord");
const parseDockerLikeLabels_1 = require("./parseDockerLikeLabels");
const parseListFilesCommandOutput_1 = require("./parseListFilesCommandOutput");
const tryParseSize_1 = require("./tryParseSize");
const withContainerPathArg_1 = require("./withContainerPathArg");
const withDockerAddHostArg_1 = require("./withDockerAddHostArg");
const withDockerBuildArg_1 = require("./withDockerBuildArg");
const withDockerEnvArg_1 = require("./withDockerEnvArg");
const withDockerExposePortsArg_1 = require("./withDockerExposePortsArg");
const withDockerFilterArg_1 = require("./withDockerFilterArg");
const withDockerIgnoreSizeArg_1 = require("./withDockerIgnoreSizeArg");
const withDockerJsonFormatArg_1 = require("./withDockerJsonFormatArg");
const withDockerLabelFilterArgs_1 = require("./withDockerLabelFilterArgs");
const withDockerLabelsArg_1 = require("./withDockerLabelsArg");
const withDockerMountsArg_1 = require("./withDockerMountsArg");
const withDockerNoTruncArg_1 = require("./withDockerNoTruncArg");
const withDockerPlatformArg_1 = require("./withDockerPlatformArg");
const withDockerPortsArg_1 = require("./withDockerPortsArg");
const parsePruneLikeOutput_1 = require("./parsePruneLikeOutput");
const LinuxStatArguments = '%f %h %g %u %s %X %Y %Z %n';
const WindowsStatArguments = '/A-S /-C /TW';
class DockerClientBase extends ConfigurableClient_1.ConfigurableClient {
    constructor() {
        super(...arguments);
        /**
         * The default registry for Docker-like clients is docker.io AKA Docker Hub
         */
        this.defaultRegistry = 'docker.io';
        /**
         * The default tag for Docker-like clients is 'latest'
         */
        this.defaultTag = 'latest';
        /**
         * The default argument given to `--format`
         */
        this.defaultFormatForJson = "{{json .}}";
        //#endregion
        //#endregion
    }
    //#region Information Commands
    getInfoCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('info'), (0, withDockerJsonFormatArg_1.withDockerJsonFormatArg)(this.defaultFormatForJson))();
    }
    async parseInfoCommandOutput(output, strict) {
        const info = JSON.parse(output);
        if (!(0, DockerInfoRecord_1.isDockerInfoRecord)(info)) {
            throw new Error('Invalid info JSON');
        }
        return {
            operatingSystem: info.OperatingSystem,
            osType: info.OSType,
            raw: output,
        };
    }
    async info(options) {
        return {
            command: this.commandName,
            args: this.getInfoCommandArgs(options),
            parse: this.parseInfoCommandOutput,
        };
    }
    /**
     * Get the command line arguments for a Docker-like client version command
     * @param options Standard version command options
     * @returns Command line args for getting version information from a Docker-like client
     */
    getVersionCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('version'), (0, withDockerJsonFormatArg_1.withDockerJsonFormatArg)(this.defaultFormatForJson))();
    }
    /**
     * Parse/normalize the output from running a Docker-like client version command
     * @param output The standard out from invoking the version command
     * @param strict Use strict parsing to validate the command?
     * @returns
     */
    async parseVersionCommandOutput(output, strict) {
        const version = JSON.parse(output);
        if (!(0, DockerVersionRecord_1.isDockerVersionRecord)(version)) {
            throw new Error('Invalid version JSON');
        }
        return {
            client: version.Client.ApiVersion,
            server: version.Server.ApiVersion,
        };
    }
    /**
     * Version command implementation for Docker-like clients
     * @param options Standard version command options
     * @returns A CommandResponse object indicating how to run and parse a version command for this runtime
     */
    async version(options) {
        return {
            command: this.commandName,
            args: this.getVersionCommandArgs(options),
            parse: this.parseVersionCommandOutput,
        };
    }
    /**
     * Get the command line arguments for a Docker-like client install check command
     * @param options Standard install check command options
     * @returns Command line args for doing install check for a Docker-like client
     */
    getCheckInstallCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('-v'))();
    }
    /**
     * Install check command implementation for Docker-like clients
     * @param options Standard install check command options
     * @returns A CommandResponse object indicating how to run and parse an install check
     * command for this runtime
     */
    async checkInstall(options) {
        return {
            command: this.commandName,
            args: this.getCheckInstallCommandArgs(options),
            parse: (output) => Promise.resolve(output),
        };
    }
    getEventStreamCommandArgs(options) {
        var _a, _b, _c, _d;
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('events'), (0, commandLineBuilder_1.withNamedArg)('--since', (_a = options.since) === null || _a === void 0 ? void 0 : _a.toString(), { shouldQuote: !(typeof options.since === 'number') }), // If it's numeric it should not be quoted
        (0, commandLineBuilder_1.withNamedArg)('--until', (_b = options.until) === null || _b === void 0 ? void 0 : _b.toString(), { shouldQuote: !(typeof options.until === 'number') }), // If it's numeric it should not be quoted
        (0, withDockerLabelFilterArgs_1.withDockerLabelFilterArgs)(options.labels), (0, withDockerFilterArg_1.withDockerFilterArg)((_c = options.types) === null || _c === void 0 ? void 0 : _c.map((type) => `type=${type}`)), (0, withDockerFilterArg_1.withDockerFilterArg)((_d = options.events) === null || _d === void 0 ? void 0 : _d.map((event) => `event=${event}`)), (0, withDockerJsonFormatArg_1.withDockerJsonFormatArg)(this.defaultFormatForJson))();
    }
    async *parseEventStreamCommandOutput(options, output, strict, cancellationToken) {
        cancellationToken || (cancellationToken = CancellationTokenLike_1.CancellationTokenLike.None);
        const lineReader = readline.createInterface({
            input: output,
            crlfDelay: Infinity,
        });
        for await (const line of lineReader) {
            if (cancellationToken.isCancellationRequested) {
                throw new CancellationError_1.CancellationError('Event stream cancelled', cancellationToken);
            }
            try {
                // Parse a line at a time
                const item = JSON.parse(line);
                if (!(0, DockerEventRecord_1.isDockerEventRecord)(item)) {
                    throw new Error('Invalid event JSON');
                }
                // Yield the parsed data
                yield {
                    type: item.Type,
                    action: item.Action,
                    actor: { id: item.Actor.ID, attributes: item.Actor.Attributes },
                    timestamp: new Date(item.time),
                    raw: JSON.stringify(line),
                };
            }
            catch (err) {
                if (strict) {
                    throw err;
                }
            }
        }
    }
    async getEventStream(options) {
        return {
            command: this.commandName,
            args: this.getEventStreamCommandArgs(options),
            parseStream: (output, strict) => this.parseEventStreamCommandOutput(options, output, strict),
        };
    }
    //#endregion
    //#region Auth Commands
    getLoginCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('login'), (0, commandLineBuilder_1.withNamedArg)('--username', options.username), (0, commandLineBuilder_1.withArg)('--password-stdin'), (0, commandLineBuilder_1.withArg)(options.registry))();
    }
    async login(options) {
        return {
            command: this.commandName,
            args: this.getLoginCommandArgs(options),
        };
    }
    getLogoutCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('logout'), (0, commandLineBuilder_1.withArg)(options.registry))();
    }
    async logout(options) {
        return {
            command: this.commandName,
            args: this.getLogoutCommandArgs(options),
        };
    }
    //#endregion
    //#region Image Commands
    //#region BuildImage Command
    /**
     * Get build image command arguments for the current runtime
     * @param options Standard build image command options
     * @returns Command line args for running a build image command on the current runtime
     */
    getBuildImageCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('image', 'build'), (0, commandLineBuilder_1.withFlagArg)('--pull', options.pull), (0, commandLineBuilder_1.withNamedArg)('--file', options.file), (0, commandLineBuilder_1.withNamedArg)('--target', options.stage), (0, commandLineBuilder_1.withNamedArg)('--tag', options.tags), (0, commandLineBuilder_1.withNamedArg)('--disable-content-trust', typeof options.disableContentTrust === 'boolean'
            ? options.disableContentTrust.toString()
            : options.disableContentTrust), (0, withDockerLabelsArg_1.withDockerLabelsArg)(options.labels), (0, commandLineBuilder_1.withNamedArg)('--iidfile', options.imageIdFile), (0, withDockerPlatformArg_1.withDockerPlatformArg)(options.platform), (0, withDockerBuildArg_1.withDockerBuildArg)(options.args), (0, commandLineBuilder_1.withVerbatimArg)(options.customOptions), (0, commandLineBuilder_1.withQuotedArg)(options.path))();
    }
    /**
     * Implements the build image command for a Docker-like runtime
     * @param options Standard build image command options
     * @returns A CommandResponse object that can be used to invoke and parse the build image command for the current runtime
     */
    async buildImage(options) {
        return {
            command: this.commandName,
            args: this.getBuildImageCommandArgs(options),
        };
    }
    //#endregion
    //#region ListImages Command
    /**
     * Get list images command arguments for the current runtime
     * @param options The process that runs the list images command for a given runtime
     * @returns Command line args for running a list image command on the current runtime
     */
    getListImagesCommandArgs(options) {
        var _a;
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('image', 'ls'), (0, commandLineBuilder_1.withFlagArg)('--all', options.all), (0, withDockerFilterArg_1.withDockerBooleanFilterArg)('dangling', options.dangling), (0, withDockerFilterArg_1.withDockerFilterArg)((_a = options.references) === null || _a === void 0 ? void 0 : _a.map((reference) => `reference=${reference}`)), (0, withDockerLabelFilterArgs_1.withDockerLabelFilterArgs)(options.labels), withDockerNoTruncArg_1.withDockerNoTruncArg, (0, withDockerJsonFormatArg_1.withDockerJsonFormatArg)(this.defaultFormatForJson))();
    }
    /**
     * Parse and normalize the standard out from a Docker-like list images command
     * @param options List images command options
     * @param output The standard out from the list images command
     * @param strict Should the output be strictly parsed?
     * @returns A normalized array of ListImagesItem records
     */
    async parseListImagesCommandOutput(options, output, strict) {
        const images = new Array();
        try {
            // Docker returns JSON per-line output, so we need to split each line
            // and parse as independent JSON objects
            output.split('\n').forEach((imageJson) => {
                try {
                    // Ignore empty lines when parsing
                    if (!imageJson) {
                        return;
                    }
                    const rawImage = JSON.parse(imageJson);
                    // Validate that the image object matches the expected output
                    // for the list images command
                    if (!(0, DockerListImageRecord_1.isDockerListImageRecord)(rawImage)) {
                        throw new Error('Invalid image JSON');
                    }
                    images.push((0, DockerListImageRecord_1.normalizeDockerListImageRecord)(rawImage));
                }
                catch (err) {
                    if (strict) {
                        throw err;
                    }
                }
            });
        }
        catch (err) {
            if (strict) {
                throw err;
            }
        }
        return images;
    }
    /**
     * Generates the necessary information for running and parsing the results
     * of a list image command for a Docker-like client
     * @param options Standard list images command options
     * @returns A CommandResponse indicating how to run and parse/normalize a list image command for a Docker-like client
     */
    async listImages(options) {
        return {
            command: this.commandName,
            args: this.getListImagesCommandArgs(options),
            parse: (output, strict) => this.parseListImagesCommandOutput(options, output, strict),
        };
    }
    //#endregion
    //#region RemoveImages Command
    getRemoveImagesCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('image', 'rm'), // Docker supports both `remove` and `rm`, but Podman supports only `rm`
        (0, commandLineBuilder_1.withFlagArg)('--force', options.force), (0, commandLineBuilder_1.withArg)(...options.imageRefs))();
    }
    async parseRemoveImagesCommandOutput(options, output, strict) {
        return (0, asIds_1.asIds)(output);
    }
    async removeImages(options) {
        return {
            command: this.commandName,
            args: this.getRemoveImagesCommandArgs(options),
            parse: (output, strict) => this.parseRemoveImagesCommandOutput(options, output, strict),
        };
    }
    //#endregion
    //#region PushImage Command
    getPushImageCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('image', 'push'), (0, commandLineBuilder_1.withArg)(options.imageRef))();
    }
    async pushImage(options) {
        return {
            command: this.commandName,
            args: this.getPushImageCommandArgs(options),
        };
    }
    //#endregion
    //#region PruneImages Command
    getPruneImagesCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('image', 'prune'), (0, commandLineBuilder_1.withArg)('--force'), (0, commandLineBuilder_1.withFlagArg)('--all', options.all))();
    }
    parsePruneImagesCommandOutput(options, output, strict) {
        const deletedImageLineRegex = /^(?:deleted:\s*sha256:\s*)(\w+)$/igm;
        const deletedImages = (0, parsePruneLikeOutput_1.parsePruneLikeOutput)(output, {
            resourceRegex: deletedImageLineRegex,
        });
        return Promise.resolve({
            imageRefsDeleted: deletedImages.resources,
            spaceReclaimed: deletedImages.spaceReclaimed,
        });
    }
    async pruneImages(options) {
        return {
            command: this.commandName,
            args: this.getPruneImagesCommandArgs(options),
            parse: (output, strict) => this.parsePruneImagesCommandOutput(options, output, strict),
        };
    }
    //#endregion
    //#region PullImage Command
    /**
     * Generate the command line arguments for invoking a pull image command on
     * a Docker-like client
     * @param options Pull image command options
     * @returns Command line arguments for pulling a container image
     */
    getPullImageCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('image', 'pull'), (0, commandLineBuilder_1.withFlagArg)('--all-tags', options.allTags), (0, commandLineBuilder_1.withNamedArg)('--disable-content-trust', typeof options.disableContentTrust === 'boolean'
            ? options.disableContentTrust.toString()
            : undefined), (0, commandLineBuilder_1.withArg)(options.imageRef))();
    }
    async pullImage(options) {
        return {
            command: this.commandName,
            args: this.getPullImageCommandArgs(options),
        };
    }
    //#endregion
    //#region TagImage Command
    getTagImageCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('image', 'tag'), (0, commandLineBuilder_1.withArg)(options.fromImageRef, options.toImageRef))();
    }
    async tagImage(options) {
        return {
            command: this.commandName,
            args: this.getTagImageCommandArgs(options),
        };
    }
    //#endregion
    //#region InspectImages Command
    /**
     * Generate the command line arguments to run an inspect images command on a
     * Docker-like client
     * @param options Standard inspect images options
     * @returns Command line args to run an inspect images command on a given Docker-like client
     */
    getInspectImagesCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('image', 'inspect'), (0, withDockerJsonFormatArg_1.withDockerJsonFormatArg)(this.defaultFormatForJson), (0, commandLineBuilder_1.withArg)(...options.imageRefs))();
    }
    /**
     * Parse the standard output from a Docker-like inspect images command and
     * normalize the result
     * @param options Inspect images command options
     * @param output The standard out from a Docker-like runtime inspect images command
     * @param strict Should strict parsing be enforced?
     * @returns Normalized array of InspectImagesItem records
     */
    async parseInspectImagesCommandOutput(options, output, strict) {
        try {
            return output.split('\n').reduce((images, inspectString) => {
                if (!inspectString) {
                    return images;
                }
                try {
                    const inspect = JSON.parse(inspectString);
                    if (!(0, DockerInspectImageRecord_1.isDockerInspectImageRecord)(inspect)) {
                        throw new Error('Invalid image inspect json');
                    }
                    return [...images, (0, DockerInspectImageRecord_1.normalizeDockerInspectImageRecord)(inspect)];
                }
                catch (err) {
                    if (strict) {
                        throw err;
                    }
                }
                return images;
            }, new Array());
        }
        catch (err) {
            if (strict) {
                throw err;
            }
        }
        // If there were no image records or there was a parsing error but
        // strict parsing was disabled, return an empty array
        return new Array();
    }
    async inspectImages(options) {
        return {
            command: this.commandName,
            args: this.getInspectImagesCommandArgs(options),
            parse: (output, strict) => this.parseInspectImagesCommandOutput(options, output, strict),
        };
    }
    //#endregion
    //#endregion
    //#region Container Commands
    //#region RunContainer Command
    /**
     * Generate the command line arguments for a Docker-like run container
     * command
     * @param options Standard run container options
     * @returns Command line arguments for a Docker-like run container command
     */
    getRunContainerCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('container', 'run'), (0, commandLineBuilder_1.withFlagArg)('--detach', options.detached), (0, commandLineBuilder_1.withFlagArg)('--interactive', options.interactive), (0, commandLineBuilder_1.withFlagArg)('--tty', options.detached || options.interactive), (0, commandLineBuilder_1.withFlagArg)('--rm', options.removeOnExit), (0, commandLineBuilder_1.withNamedArg)('--name', options.name), (0, withDockerPortsArg_1.withDockerPortsArg)(options.ports), (0, commandLineBuilder_1.withFlagArg)('--publish-all', options.publishAllPorts), (0, commandLineBuilder_1.withNamedArg)('--network', options.network), (0, commandLineBuilder_1.withNamedArg)('--network-alias', options.networkAlias), (0, withDockerAddHostArg_1.withDockerAddHostArg)(options.addHost), (0, withDockerMountsArg_1.withDockerMountsArg)(options.mounts), (0, withDockerLabelsArg_1.withDockerLabelsArg)(options.labels), (0, withDockerEnvArg_1.withDockerEnvArg)(options.environmentVariables), (0, commandLineBuilder_1.withNamedArg)('--env-file', options.environmentFiles), (0, commandLineBuilder_1.withNamedArg)('--entrypoint', options.entrypoint), (0, withDockerExposePortsArg_1.withDockerExposePortsArg)(options.exposePorts), (0, commandLineBuilder_1.withVerbatimArg)(options.customOptions), (0, commandLineBuilder_1.withArg)(options.imageRef), typeof options.command === 'string' ? (0, commandLineBuilder_1.withVerbatimArg)(options.command) : (0, commandLineBuilder_1.withArg)(...((0, toArray_1.toArray)(options.command || []))))();
    }
    /**
     * Parse standard output for a run container command
     * @param options The standard run container command options
     * @param output Standard output for a run container command
     * @param strict Should strict parsing be enforced
     * @returns The container ID if running detached or standard out if running attached
     */
    async parseRunContainerCommandOutput(options, output, strict) {
        return options.detached ? output.split('\n', 1)[0] : output;
    }
    /**
     * Generate a CommandResponse for a Docker-like run container command that includes how to run and parse command output
     * @param options Standard run container command options
     * @returns A CommandResponse object for a Docker-like run container command
     */
    async runContainer(options) {
        return {
            command: this.commandName,
            args: this.getRunContainerCommandArgs(options),
            parse: (output, strict) => this.parseRunContainerCommandOutput(options, output, strict),
        };
    }
    //#endregion
    //#region ExecContainer Command
    getExecContainerCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('container', 'exec'), (0, commandLineBuilder_1.withFlagArg)('--interactive', options.interactive), (0, commandLineBuilder_1.withFlagArg)('--detached', options.detached), (0, commandLineBuilder_1.withFlagArg)('--tty', options.tty), (0, withDockerEnvArg_1.withDockerEnvArg)(options.environmentVariables), (0, commandLineBuilder_1.withArg)(options.container), typeof options.command === 'string' ? (0, commandLineBuilder_1.withVerbatimArg)(options.command) : (0, commandLineBuilder_1.withArg)(...(0, toArray_1.toArray)(options.command)))();
    }
    async execContainer(options) {
        return {
            command: this.commandName,
            args: this.getExecContainerCommandArgs(options),
            parseStream: (output, strict) => (0, streamToGenerator_1.stringStreamToGenerator)(output),
        };
    }
    //#endregion
    //#region ListContainers Command
    getListContainersCommandArgs(options) {
        var _a, _b, _c, _d;
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('container', 'ls'), (0, commandLineBuilder_1.withFlagArg)('--all', options.all), (0, withDockerLabelFilterArgs_1.withDockerLabelFilterArgs)(options.labels), (0, withDockerFilterArg_1.withDockerFilterArg)(options.running ? 'status=running' : undefined), (0, withDockerFilterArg_1.withDockerFilterArg)(options.exited ? 'status=exited' : undefined), (0, withDockerFilterArg_1.withDockerFilterArg)((_a = options.names) === null || _a === void 0 ? void 0 : _a.map((name) => `name=${name}`)), (0, withDockerFilterArg_1.withDockerFilterArg)((_b = options.imageAncestors) === null || _b === void 0 ? void 0 : _b.map((id) => `ancestor=${id}`)), (0, withDockerFilterArg_1.withDockerFilterArg)((_c = options.volumes) === null || _c === void 0 ? void 0 : _c.map((volume) => `volume=${volume}`)), (0, withDockerFilterArg_1.withDockerFilterArg)((_d = options.networks) === null || _d === void 0 ? void 0 : _d.map((network) => `network=${network}`)), withDockerNoTruncArg_1.withDockerNoTruncArg, (0, withDockerJsonFormatArg_1.withDockerJsonFormatArg)(this.defaultFormatForJson), withDockerIgnoreSizeArg_1.withDockerIgnoreSizeArg)();
    }
    async parseListContainersCommandOutput(options, output, strict) {
        const containers = new Array();
        try {
            output.split('\n').forEach((containerJson) => {
                try {
                    if (!containerJson) {
                        return;
                    }
                    const rawContainer = JSON.parse(containerJson);
                    if (!(0, DockerListContainerRecord_1.isDockerListContainerRecord)(rawContainer)) {
                        throw new Error('Invalid container JSON');
                    }
                    containers.push((0, DockerListContainerRecord_1.normalizeDockerListContainerRecord)(rawContainer, strict));
                }
                catch (err) {
                    if (strict) {
                        throw err;
                    }
                }
            });
        }
        catch (err) {
            if (strict) {
                throw err;
            }
        }
        return containers;
    }
    async listContainers(options) {
        return {
            command: this.commandName,
            args: this.getListContainersCommandArgs(options),
            parse: (output, strict) => this.parseListContainersCommandOutput(options, output, strict),
        };
    }
    //#endregion
    //#region StartContainers Command
    getStartContainersCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('container', 'start'), (0, commandLineBuilder_1.withArg)(...(0, toArray_1.toArray)(options.container)))();
    }
    async parseStartContainersCommandOutput(options, output, strict) {
        return (0, asIds_1.asIds)(output);
    }
    async startContainers(options) {
        return {
            command: this.commandName,
            args: this.getStartContainersCommandArgs(options),
            parse: (output, strict) => this.parseStartContainersCommandOutput(options, output, strict),
        };
    }
    //#endregion
    //#region RestartContainers Command
    getRestartContainersCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('container', 'restart'), (0, commandLineBuilder_1.withArg)(...(0, toArray_1.toArray)(options.container)))();
    }
    async parseRestartContainersCommandOutput(options, output, strict) {
        return (0, asIds_1.asIds)(output);
    }
    async restartContainers(options) {
        return {
            command: this.commandName,
            args: this.getRestartContainersCommandArgs(options),
            parse: (output, strict) => this.parseRestartContainersCommandOutput(options, output, strict),
        };
    }
    //#endregion
    //#region StopContainers Command
    /**
     * Generate command line arguments for running a stop container command
     * @param options Standard stop container command options
     * @returns The command line arguments required to run the stop container command on a Docker-like runtime
     */
    getStopContainersCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('container', 'stop'), (0, commandLineBuilder_1.withNamedArg)('--time', typeof options.time === 'number' ? options.time.toString() : undefined), (0, commandLineBuilder_1.withArg)(...(0, toArray_1.toArray)(options.container)))();
    }
    /**
     * Parse the standard output from running a stop container command on a Docker-like runtime
     * @param options Stop container command options
     * @param output The standard out from the stop containers command
     * @param strict Should strict parsing be enforced
     * @returns A list of IDs for containers that were stopped
     */
    async parseStopContainersCommandOutput(options, output, strict) {
        return (0, asIds_1.asIds)(output);
    }
    async stopContainers(options) {
        return {
            command: this.commandName,
            args: this.getStopContainersCommandArgs(options),
            parse: (output, strict) => this.parseStopContainersCommandOutput(options, output, strict),
        };
    }
    //#endregion
    //#region RemoveContainers Command
    getRemoveContainersCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('container', 'rm'), (0, commandLineBuilder_1.withFlagArg)('--force', options.force), (0, commandLineBuilder_1.withArg)(...options.containers))();
    }
    async parseRemoveContainersCommandOutput(options, output, strict) {
        return (0, asIds_1.asIds)(output);
    }
    async removeContainers(options) {
        return {
            command: this.commandName,
            args: this.getRemoveContainersCommandArgs(options),
            parse: (output, strict) => this.parseRemoveContainersCommandOutput(options, output, strict),
        };
    }
    //#endregion
    //#region PruneContainers Command
    getPruneContainersCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('container', 'prune'), (0, commandLineBuilder_1.withArg)('--force'))();
    }
    async parsePruneContainersCommandOutput(options, output, strict) {
        const deletedContainerItems = (0, parsePruneLikeOutput_1.parsePruneLikeOutput)(output, {
            resourceRegex: undefined, // the line is the container ID itself
        });
        return Promise.resolve({
            containersDeleted: deletedContainerItems.resources,
            spaceReclaimed: deletedContainerItems.spaceReclaimed,
        });
    }
    async pruneContainers(options) {
        return {
            command: this.commandName,
            args: this.getPruneContainersCommandArgs(options),
            parse: (output, strict) => this.parsePruneContainersCommandOutput(options, output, strict),
        };
    }
    //#endregion
    //#region StatsContainers Command
    getStatsContainersCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('container', 'stats'), (0, commandLineBuilder_1.withFlagArg)('--all', options.all))();
    }
    async statsContainers(options) {
        return {
            command: this.commandName,
            args: this.getStatsContainersCommandArgs(options),
        };
    }
    //#endregion
    //#region LogsForContainer Command
    /**
     * Generate the command line arguments for the log container command on a
     * Docker-like client
     * @param options Options for log container command
     * @returns Command line arguments to invoke a log container command on a Docker-like client
     */
    getLogsForContainerCommandArgs(options) {
        var _a;
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('container', 'logs'), (0, commandLineBuilder_1.withFlagArg)('--follow', options.follow), (0, commandLineBuilder_1.withFlagArg)('--timestamps', options.timestamps), (0, commandLineBuilder_1.withNamedArg)('--tail', (_a = options.tail) === null || _a === void 0 ? void 0 : _a.toString()), (0, commandLineBuilder_1.withNamedArg)('--since', options.since), (0, commandLineBuilder_1.withNamedArg)('--until', options.until), (0, commandLineBuilder_1.withArg)(options.container))();
    }
    /**
     * Generate a CommandResponse object for a Docker-like log container command
     * @param options Options for the log container command
     * @returns The CommandResponse object for the log container command
     */
    async logsForContainer(options) {
        return {
            command: this.commandName,
            args: this.getLogsForContainerCommandArgs(options),
            parseStream: (output, strict) => (0, streamToGenerator_1.stringStreamToGenerator)(output),
        };
    }
    //#endregion
    //#region InspectContainers Command
    /**
     * Override this method if the default inspect containers args need to be changed for a given runtime
     * @param options Inspect containers command options
     * @returns Command line args for invoking inspect containers on a Docker-like client
     */
    getInspectContainersCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('container', 'inspect'), (0, withDockerJsonFormatArg_1.withDockerJsonFormatArg)(this.defaultFormatForJson), (0, commandLineBuilder_1.withArg)(...options.containers))();
    }
    /**
     * Parse the output from running an inspect containers command on a Docker-like client
     * @param options Inspect containers command options
     * @param output Standard out from running a Docker-like inspect containers command
     * @param strict Should strict parsing be used to parse the output?
     * @returns An array of InspectContainersItem records
     */
    async parseInspectContainersCommandOutput(options, output, strict) {
        try {
            return output.split('\n').reduce((containers, inspectString) => {
                if (!inspectString) {
                    return containers;
                }
                try {
                    const inspect = JSON.parse(inspectString);
                    if (!(0, DockerInspectContainerRecord_1.isDockerInspectContainerRecord)(inspect)) {
                        throw new Error('Invalid container inspect json');
                    }
                    return [...containers, (0, DockerInspectContainerRecord_1.normalizeDockerInspectContainerRecord)(inspect)];
                }
                catch (err) {
                    if (strict) {
                        throw err;
                    }
                }
                return containers;
            }, new Array());
        }
        catch (err) {
            if (strict) {
                throw err;
            }
        }
        return new Array();
    }
    async inspectContainers(options) {
        return {
            command: this.commandName,
            args: this.getInspectContainersCommandArgs(options),
            parse: (output, strict) => this.parseInspectContainersCommandOutput(options, output, strict),
        };
    }
    //#endregion
    //#endregion
    //#region Volume Commands
    //#region CreateVolume Command
    getCreateVolumeCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('volume', 'create'), (0, commandLineBuilder_1.withNamedArg)('--driver', options.driver), (0, commandLineBuilder_1.withArg)(options.name))();
    }
    async createVolume(options) {
        return {
            command: this.commandName,
            args: this.getCreateVolumeCommandArgs(options),
        };
    }
    //#endregion
    //#region ListVolumes Command
    getListVolumesCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('volume', 'ls'), (0, withDockerFilterArg_1.withDockerBooleanFilterArg)('dangling', options.dangling), (0, withDockerFilterArg_1.withDockerFilterArg)(options.driver ? `driver=${options.driver}` : undefined), (0, withDockerLabelFilterArgs_1.withDockerLabelFilterArgs)(options.labels), (0, withDockerJsonFormatArg_1.withDockerJsonFormatArg)(this.defaultFormatForJson))();
    }
    async parseListVolumesCommandOutput(options, output, strict) {
        const volumes = new Array();
        try {
            output.split("\n").forEach((volumeJson) => {
                try {
                    if (!volumeJson) {
                        return;
                    }
                    const rawVolume = JSON.parse(volumeJson);
                    if (!(0, DockerVolumeRecord_1.isDockerVolumeRecord)(rawVolume)) {
                        throw new Error('Invalid volume JSON');
                    }
                    // Parse the labels assigned to the volumes and normalize to key value pairs
                    const labels = (0, parseDockerLikeLabels_1.parseDockerLikeLabels)(rawVolume.Labels);
                    const createdAt = rawVolume.CreatedAt
                        ? dayjs_1.dayjs.utc(rawVolume.CreatedAt)
                        : undefined;
                    const size = (0, tryParseSize_1.tryParseSize)(rawVolume.Size);
                    volumes.push({
                        name: rawVolume.Name,
                        driver: rawVolume.Driver,
                        labels,
                        mountpoint: rawVolume.Mountpoint,
                        scope: rawVolume.Scope,
                        createdAt: createdAt === null || createdAt === void 0 ? void 0 : createdAt.toDate(),
                        size
                    });
                }
                catch (err) {
                    if (strict) {
                        throw err;
                    }
                }
            });
        }
        catch (err) {
            if (strict) {
                throw err;
            }
        }
        return volumes;
    }
    async listVolumes(options) {
        return {
            command: this.commandName,
            args: this.getListVolumesCommandArgs(options),
            parse: (output, strict) => this.parseListVolumesCommandOutput(options, output, strict),
        };
    }
    //#endregion
    //#region RemoveVolumes Command
    /**
     * Generate the command line arguments for a Docker-like remove volumes
     * command
     * @param options Remove volumes command options
     * @returns Command line arguments for invoking a remove volumes command
     */
    getRemoveVolumesCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('volume', 'rm'), (0, commandLineBuilder_1.withFlagArg)('--force', options.force), (0, commandLineBuilder_1.withArg)(...options.volumes))();
    }
    /**
     * Parse the output from running a Docker-like remove volumes command
     * @param options Options for the remove volumes command
     * @param output Standard out from running the remove volumes command
     * @param strict Should strict parsing be enforced?
     * @returns A list of IDs for the volumes removed
     */
    async parseRemoveVolumesCommandOutput(options, output, strict) {
        return (0, asIds_1.asIds)(output);
    }
    /**
     * Generate a CommandResponse instance for a Docker-like remove volumes
     * command
     * @param options Options for remove volumes command
     * @returns CommandResponse for the remove volumes command
     */
    async removeVolumes(options) {
        return {
            command: this.commandName,
            args: this.getRemoveVolumesCommandArgs(options),
            parse: (output, strict) => this.parseRemoveVolumesCommandOutput(options, output, strict),
        };
    }
    //#endregion
    //#region PruneVolumes Command
    getPruneVolumesCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('volume', 'prune'), (0, commandLineBuilder_1.withArg)('--force'))();
    }
    async parsePruneVolumesCommandOutput(options, output, strict) {
        const deletedVolumes = (0, parsePruneLikeOutput_1.parsePruneLikeOutput)(output, {
            resourceRegex: undefined, // the line is the volume name or ID itself
        });
        return Promise.resolve({
            volumesDeleted: deletedVolumes.resources,
            spaceReclaimed: deletedVolumes.spaceReclaimed,
        });
    }
    async pruneVolumes(options) {
        return {
            command: this.commandName,
            args: this.getPruneVolumesCommandArgs(options),
            parse: (output, strict) => this.parsePruneVolumesCommandOutput(options, output, strict),
        };
    }
    //#endregion
    //#region InspectVolumes Command
    getInspectVolumesCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('volume', 'inspect'), (0, withDockerJsonFormatArg_1.withDockerJsonFormatArg)(this.defaultFormatForJson), (0, commandLineBuilder_1.withArg)(...options.volumes))();
    }
    async parseInspectVolumesCommandOutput(options, output, strict) {
        try {
            return output.split('\n').reduce((volumes, inspectString) => {
                if (!inspectString) {
                    return volumes;
                }
                try {
                    const inspect = JSON.parse(inspectString);
                    if (!(0, DockerInspectVolumeRecord_1.isDockerInspectVolumeRecord)(inspect)) {
                        throw new Error('Invalid volume inspect json');
                    }
                    return [...volumes, (0, DockerInspectVolumeRecord_1.normalizeDockerInspectVolumeRecord)(inspect)];
                }
                catch (err) {
                    if (strict) {
                        throw err;
                    }
                }
                return volumes;
            }, new Array());
        }
        catch (err) {
            if (strict) {
                throw err;
            }
        }
        return new Array();
    }
    async inspectVolumes(options) {
        return {
            command: this.commandName,
            args: this.getInspectVolumesCommandArgs(options),
            parse: (output, strict) => this.parseInspectVolumesCommandOutput(options, output, strict),
        };
    }
    //#endregion
    //#endregion
    //#region Network Commands
    //#region CreateNetwork Command
    getCreateNetworkCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('network', 'create'), (0, commandLineBuilder_1.withNamedArg)('--driver', options.driver), (0, commandLineBuilder_1.withArg)(options.name))();
    }
    async createNetwork(options) {
        return {
            command: this.commandName,
            args: this.getCreateNetworkCommandArgs(options),
        };
    }
    //#endregion
    //#region ListNetworks Command
    getListNetworksCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('network', 'ls'), (0, withDockerLabelFilterArgs_1.withDockerLabelFilterArgs)(options.labels), withDockerNoTruncArg_1.withDockerNoTruncArg, (0, withDockerJsonFormatArg_1.withDockerJsonFormatArg)(this.defaultFormatForJson))();
    }
    async parseListNetworksCommandOutput(options, output, strict) {
        const networks = new Array();
        try {
            output.split("\n").forEach((networkJson) => {
                try {
                    if (!networkJson) {
                        return;
                    }
                    const rawNetwork = JSON.parse(networkJson);
                    if (!(0, DockerListNetworkRecord_1.isDockerListNetworkRecord)(rawNetwork)) {
                        throw new Error('Invalid volume JSON');
                    }
                    networks.push((0, DockerListNetworkRecord_1.normalizeDockerListNetworkRecord)(rawNetwork));
                }
                catch (err) {
                    if (strict) {
                        throw err;
                    }
                }
            });
        }
        catch (err) {
            if (strict) {
                throw err;
            }
        }
        return networks;
    }
    async listNetworks(options) {
        return {
            command: this.commandName,
            args: this.getListNetworksCommandArgs(options),
            parse: (output, strict) => this.parseListNetworksCommandOutput(options, output, strict),
        };
    }
    //#endregion
    //#region RemoveNetworks Command
    getRemoveNetworksCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('network', 'remove'), (0, commandLineBuilder_1.withFlagArg)('--force', options.force), (0, commandLineBuilder_1.withArg)(...options.networks))();
    }
    async parseRemoveNetworksCommandOutput(options, output, strict) {
        return output.split('\n').map((id) => id);
    }
    async removeNetworks(options) {
        return {
            command: this.commandName,
            args: this.getRemoveNetworksCommandArgs(options),
            parse: (output, strict) => this.parseRemoveNetworksCommandOutput(options, output, strict),
        };
    }
    //#endregion
    //#region PruneNetworks Command
    getPruneNetworksCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('network', 'prune'), (0, commandLineBuilder_1.withArg)('--force'))();
    }
    async parsePruneNetworksCommandOutput(options, output, strict) {
        let networks = [];
        const deletedNetworkStartString = "Deleted Networks:";
        if (output.includes(deletedNetworkStartString)) {
            networks = (0, asIds_1.asIds)(output.replace(deletedNetworkStartString, ""));
        }
        return {
            networksDeleted: networks,
        };
    }
    async pruneNetworks(options) {
        return {
            command: this.commandName,
            args: this.getPruneNetworksCommandArgs(options),
            parse: (output, strict) => this.parsePruneNetworksCommandOutput(options, output, strict),
        };
    }
    //#endregion
    //#region InspectNetworks Command
    getInspectNetworksCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('network', 'inspect'), (0, withDockerJsonFormatArg_1.withDockerJsonFormatArg)(this.defaultFormatForJson), (0, commandLineBuilder_1.withArg)(...options.networks))();
    }
    async parseInspectNetworksCommandOutput(options, output, strict) {
        try {
            return output.split('\n').reduce((networks, inspectString) => {
                if (!inspectString) {
                    return networks;
                }
                try {
                    const inspect = JSON.parse(inspectString);
                    if (!(0, DockerInspectNetworkRecord_1.isDockerInspectNetworkRecord)(inspect)) {
                        throw new Error('Invalid network inspect json');
                    }
                    return [...networks, (0, DockerInspectNetworkRecord_1.normalizeDockerInspectNetworkRecord)(inspect)];
                }
                catch (err) {
                    if (strict) {
                        throw err;
                    }
                }
                return networks;
            }, new Array());
        }
        catch (err) {
            if (strict) {
                throw err;
            }
        }
        return new Array();
    }
    async inspectNetworks(options) {
        return {
            command: this.commandName,
            args: this.getInspectNetworksCommandArgs(options),
            parse: (output, strict) => this.parseInspectNetworksCommandOutput(options, output, strict),
        };
    }
    //#endregion
    //#endregion
    //#region Context Commands
    //#region ListContexts Command
    async listContexts(options) {
        throw new CommandNotSupportedError_1.CommandNotSupportedError('listContexts is not supported for this runtime');
    }
    //#endregion
    //#region RemoveContexts Command
    async removeContexts(options) {
        throw new CommandNotSupportedError_1.CommandNotSupportedError('removeContexts is not supported for this runtime');
    }
    //#endregion
    //#region UseContext Command
    async useContext(options) {
        throw new CommandNotSupportedError_1.CommandNotSupportedError('useContext is not supported for this runtime');
    }
    //#endregion
    //#region InspectContexts Command
    async inspectContexts(options) {
        throw new CommandNotSupportedError_1.CommandNotSupportedError('inspectContexts is not supported for this runtime');
    }
    //#endregion
    //#endregion
    //#region File Commands
    //#region ListFiles Command
    getListFilesCommandArgs(options) {
        let command;
        if (options.operatingSystem === 'windows') {
            command = [
                'cmd',
                '/D',
                '/S',
                '/C',
                `dir ${WindowsStatArguments} "${options.path}"`,
            ];
        }
        else {
            const dirPath = options.path.endsWith('/') ? options.path : options.path + '/';
            // Calling stat <path>/* on an empty directory returns an error code, while stat <path>/.* may not match
            // implicit . and .. relative folders depending on system configuration. Therefore we call stat for both wildcard
            // patterns and suppress errors with || true. Additionally, we explicitly call stat for the implicit . path and if
            // there are any legitimate issues invoking stat in a given container, this call should still fail and surface the
            // actual error, allowing us to suppress a false error without suppressing legitimate issues.
            command = [
                '/bin/sh',
                '-c',
                { value: `stat -c '${LinuxStatArguments}' "${dirPath}"* || true && stat -c '${LinuxStatArguments}' "${dirPath}".* || true && stat -c '${LinuxStatArguments}' "${dirPath}".`, quoting: vscode_1.ShellQuoting.Strong },
            ];
        }
        return this.getExecContainerCommandArgs({
            container: options.container,
            interactive: true,
            command,
        });
    }
    async parseListFilesCommandOutput(options, output, strict) {
        if (options.operatingSystem === 'windows') {
            return (0, parseListFilesCommandOutput_1.parseListFilesCommandWindowsOutput)(options, output);
        }
        else {
            return (0, parseListFilesCommandOutput_1.parseListFilesCommandLinuxOutput)(options, output);
        }
    }
    async listFiles(options) {
        return {
            command: this.commandName,
            args: this.getListFilesCommandArgs(options),
            parse: (output, strict) => this.parseListFilesCommandOutput(options, output, strict),
        };
    }
    //#endregion
    //#region StatPath Command
    getStatPathCommandArgs(options) {
        let command;
        if (options.operatingSystem === 'windows') {
            command = [
                'cmd',
                '/D',
                '/S',
                '/C',
                `dir ${WindowsStatArguments} "${options.path}"`,
            ];
        }
        else {
            command = [
                '/bin/sh',
                '-c',
                { value: `stat -c '${LinuxStatArguments}' "${options.path}"`, quoting: vscode_1.ShellQuoting.Strong },
            ];
        }
        return this.getExecContainerCommandArgs({
            container: options.container,
            interactive: true,
            command,
        });
    }
    async parseStatPathCommandOutput(options, output, strict) {
        if (options.operatingSystem === 'windows') {
            return (0, parseListFilesCommandOutput_1.parseListFilesCommandWindowsOutput)(options, output).shift();
        }
        else {
            return (0, parseListFilesCommandOutput_1.parseListFilesCommandLinuxOutput)(options, output).shift();
        }
    }
    async statPath(options) {
        return {
            command: this.commandName,
            args: this.getStatPathCommandArgs(options),
            parse: (output, strict) => this.parseStatPathCommandOutput(options, output, strict),
        };
    }
    //#endregion
    //#region ReadFile Command
    getReadFileCommandArgs(options) {
        if (options.operatingSystem === 'windows') {
            const command = [
                'cmd',
                '/D',
                '/S',
                '/C',
                `type "${options.path}"`,
            ];
            return this.getExecContainerCommandArgs({
                container: options.container,
                interactive: true,
                command,
            });
        }
        else {
            return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('cp'), (0, withContainerPathArg_1.withContainerPathArg)(options), (0, commandLineBuilder_1.withArg)('-'))();
        }
    }
    async readFile(options) {
        return {
            command: this.commandName,
            args: this.getReadFileCommandArgs(options),
            parseStream: (output, strict) => (0, streamToGenerator_1.byteStreamToGenerator)(output),
        };
    }
    //#endregion
    //#region WriteFile Command
    getWriteFileCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('cp'), (0, commandLineBuilder_1.withArg)(options.inputFile || '-'), (0, withContainerPathArg_1.withContainerPathArg)(options))();
    }
    async writeFile(options) {
        return {
            command: this.commandName,
            args: this.getWriteFileCommandArgs(options),
        };
    }
}
exports.DockerClientBase = DockerClientBase;
//# sourceMappingURL=DockerClientBase.js.map