"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See LICENSE in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.DockerClient = void 0;
const asIds_1 = require("../../utils/asIds");
const commandLineBuilder_1 = require("../../utils/commandLineBuilder");
const DockerClientBase_1 = require("../DockerClientBase/DockerClientBase");
const withDockerJsonFormatArg_1 = require("../DockerClientBase/withDockerJsonFormatArg");
const DockerContextRecord_1 = require("./DockerContextRecord");
const DockerInspectContextRecord_1 = require("./DockerInspectContextRecord");
class DockerClient extends DockerClientBase_1.DockerClientBase {
    /**
     * Constructs a new {@link DockerClient}
     * @param commandName (Optional, default `docker`) The command that will be run
     * as the base command. If quoting is necessary, it is the responsibility of the
     * caller to add.
     * @param displayName (Optional, default 'Docker') The human-friendly display
     * name of the client
     * @param description (Optional, with default) The human-friendly description of
     * the client
     */
    constructor(commandName = 'docker', displayName = 'Docker', description = 'Runs container commands using the Docker CLI') {
        super(DockerClient.ClientId, commandName, displayName, description);
    }
    //#region Context Commands
    //#region ListContexts Command
    getListContextsCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('context', 'ls'), (0, withDockerJsonFormatArg_1.withDockerJsonFormatArg)(this.defaultFormatForJson))();
    }
    async parseListContextsCommandOutput(output, strict) {
        const contexts = new Array();
        try {
            // Docker returns JSON per-line output, so we need to split each line
            // and parse as independent JSON objects
            output.split('\n').forEach((contextJson) => {
                try {
                    // Ignore empty lines when parsing
                    if (!contextJson) {
                        return;
                    }
                    const rawContext = JSON.parse(contextJson);
                    // Validate that the image object matches the expected output
                    // for the list contexts command
                    if (!(0, DockerContextRecord_1.isDockerContextRecord)(rawContext)) {
                        throw new Error('Invalid context JSON');
                    }
                    contexts.push({
                        name: rawContext.Name,
                        current: rawContext.Current,
                        description: rawContext.Description,
                        containerEndpoint: rawContext.DockerEndpoint,
                    });
                }
                catch (err) {
                    if (strict) {
                        throw err;
                    }
                }
            });
        }
        catch (err) {
            if (strict) {
                throw err;
            }
        }
        return contexts;
    }
    async listContexts(options) {
        return {
            command: this.commandName,
            args: this.getListContextsCommandArgs(options),
            parse: this.parseListContextsCommandOutput,
        };
    }
    //#endregion
    //#region RemoveContexts Command
    getRemoveContextsCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('context', 'rm'), (0, commandLineBuilder_1.withArg)(...options.contexts), (0, commandLineBuilder_1.withArg)('--force'))();
    }
    async parseRemoveContextsCommandOutput(output, strict) {
        return (0, asIds_1.asIds)(output);
    }
    async removeContexts(options) {
        return {
            command: this.commandName,
            args: this.getRemoveContextsCommandArgs(options),
            parse: this.parseRemoveContextsCommandOutput,
        };
    }
    //#endregion
    //#region UseContext Command
    getUseContextCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('context', 'use'), (0, commandLineBuilder_1.withArg)(options.context))();
    }
    async useContext(options) {
        return {
            command: this.commandName,
            args: this.getUseContextCommandArgs(options),
        };
    }
    //#endregion
    //#region InspectContexts Command
    getInspectContextsCommandArgs(options) {
        return (0, commandLineBuilder_1.composeArgs)((0, commandLineBuilder_1.withArg)('context', 'inspect'), (0, withDockerJsonFormatArg_1.withDockerJsonFormatArg)(this.defaultFormatForJson), (0, commandLineBuilder_1.withArg)(...options.contexts))();
    }
    async parseInspectContextsCommandOutput(output, strict) {
        try {
            return output.split('\n').reduce((volumes, inspectString) => {
                var _a;
                if (!inspectString) {
                    return volumes;
                }
                try {
                    const inspect = JSON.parse(inspectString);
                    if (!(0, DockerInspectContextRecord_1.isDockerInspectContextRecord)(inspect)) {
                        throw new Error('Invalid context inspect json');
                    }
                    // Return the normalized InspectVolumesItem record
                    const volume = {
                        name: inspect.Name,
                        description: (_a = inspect.Metadata) === null || _a === void 0 ? void 0 : _a.Description,
                        raw: inspectString,
                    };
                    return [...volumes, volume];
                }
                catch (err) {
                    if (strict) {
                        throw err;
                    }
                }
                return volumes;
            }, new Array());
        }
        catch (err) {
            if (strict) {
                throw err;
            }
        }
        return new Array();
    }
    async inspectContexts(options) {
        return {
            command: this.commandName,
            args: this.getInspectContextsCommandArgs(options),
            parse: this.parseInspectContextsCommandOutput,
        };
    }
}
exports.DockerClient = DockerClient;
/**
 * The ID of the Docker client
 */
DockerClient.ClientId = 'com.microsoft.visualstudio.containers.docker';
//# sourceMappingURL=DockerClient.js.map