"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See LICENSE in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.PodmanClient = void 0;
const readline = require("readline");
const dayjs_1 = require("../../utils/dayjs");
const parseDockerLikeImageName_1 = require("../../utils/parseDockerLikeImageName");
const PodmanListContainerRecord_1 = require("./PodmanListContainerRecord");
const PodmanListImageRecord_1 = require("./PodmanListImageRecord");
const PodmanVersionRecord_1 = require("./PodmanVersionRecord");
const DockerClientBase_1 = require("../DockerClientBase/DockerClientBase");
const CancellationTokenLike_1 = require("../../typings/CancellationTokenLike");
const CancellationError_1 = require("../../utils/CancellationError");
const PodmanEventRecord_1 = require("./PodmanEventRecord");
const asIds_1 = require("../../utils/asIds");
const PodmanInspectImageRecord_1 = require("./PodmanInspectImageRecord");
const PodmanInspectContainerRecord_1 = require("./PodmanInspectContainerRecord");
const PodmanListNetworkRecord_1 = require("./PodmanListNetworkRecord");
const PodmanInspectNetworkRecord_1 = require("./PodmanInspectNetworkRecord");
const PodmanInspectVolumeRecord_1 = require("./PodmanInspectVolumeRecord");
class PodmanClient extends DockerClientBase_1.DockerClientBase {
    /**
     * Constructs a new {@link PodmanClient}
     * @param commandName (Optional, default `podman`) The command that will be run
     * as the base command. If quoting is necessary, it is the responsibility of the
     * caller to add.
     * @param displayName (Optional, default 'Podman') The human-friendly display
     * name of the client
     * @param description (Optional, with default) The human-friendly description of
     * the client
     */
    constructor(commandName = 'podman', displayName = 'Podman', description = 'Runs container commands using the Podman CLI') {
        super(PodmanClient.ClientId, commandName, displayName, description);
        /**
         * The default argument given to `--format`
         */
        this.defaultFormatForJson = "json";
    }
    //#region Version Command
    async parseVersionCommandOutput(output, strict) {
        var _a;
        const version = JSON.parse(output);
        if (!(0, PodmanVersionRecord_1.isPodmanVersionRecord)(version)) {
            throw new Error('Invalid version JSON');
        }
        return {
            client: version.Client.APIVersion,
            server: (_a = version.Server) === null || _a === void 0 ? void 0 : _a.APIVersion,
        };
    }
    //#endregion
    //#region Info Command
    async parseInfoCommandOutput(output, strict) {
        return {
            operatingSystem: undefined,
            osType: 'linux',
            raw: output,
        };
    }
    //#endregion
    //#region GetEventStream Command
    async *parseEventStreamCommandOutput(options, output, strict, cancellationToken) {
        cancellationToken || (cancellationToken = CancellationTokenLike_1.CancellationTokenLike.None);
        const lineReader = readline.createInterface({
            input: output,
            crlfDelay: Infinity,
        });
        for await (const line of lineReader) {
            if (cancellationToken.isCancellationRequested) {
                throw new CancellationError_1.CancellationError('Event stream cancelled', cancellationToken);
            }
            try {
                // Parse a line at a time
                const item = JSON.parse(line);
                if (!(0, PodmanEventRecord_1.isPodmanEventRecord)(item)) {
                    throw new Error('Invalid event JSON');
                }
                // Yield the parsed data
                yield {
                    type: item.Type,
                    action: item.Status,
                    actor: { id: item.Name, attributes: item.Attributes || {} },
                    timestamp: new Date(item.time || item.Time || ''),
                    raw: JSON.stringify(line),
                };
            }
            catch (err) {
                if (strict) {
                    throw err;
                }
            }
        }
    }
    //#endregion
    //#region ListImages Command
    async parseListImagesCommandOutput(options, output, strict) {
        const images = new Array();
        try {
            const rawImages = JSON.parse(output);
            rawImages.forEach((rawImage) => {
                var _a;
                try {
                    if (!(0, PodmanListImageRecord_1.isPodmanListImageRecord)(rawImage)) {
                        throw new Error('Invalid image JSON');
                    }
                    const createdAt = dayjs_1.dayjs.unix(rawImage.Created).toDate();
                    // Podman lists the same image multiple times depending on how many tags it has
                    // So index the name based on how many times we've already seen this image ID
                    const countImagesOfSameId = images.filter(i => i.id === rawImage.Id).length;
                    images.push({
                        id: rawImage.Id,
                        image: (0, parseDockerLikeImageName_1.parseDockerLikeImageName)((_a = rawImage.Names) === null || _a === void 0 ? void 0 : _a[countImagesOfSameId]),
                        // labels: rawImage.Labels || {},
                        createdAt,
                        size: rawImage.Size,
                    });
                }
                catch (err) {
                    if (strict) {
                        throw err;
                    }
                }
            });
        }
        catch (err) {
            if (strict) {
                throw err;
            }
        }
        return images;
    }
    //#endregion
    //#region PruneImages Command
    parsePruneImagesCommandOutput(options, output, strict) {
        return Promise.resolve({
            imageRefsDeleted: (0, asIds_1.asIds)(output),
        });
    }
    //#endregion
    //#region InspectImages Command
    /**
     * Parse the standard output from a Docker-like inspect images command and
     * normalize the result
     * @param options Inspect images command options
     * @param output The standard out from a Docker-like runtime inspect images command
     * @param strict Should strict parsing be enforced?
     * @returns Normalized array of InspectImagesItem records
     */
    async parseInspectImagesCommandOutput(options, output, strict) {
        const results = new Array();
        try {
            const resultRaw = JSON.parse(output);
            if (!Array.isArray(resultRaw)) {
                throw new Error('Invalid image inspect json');
            }
            for (const inspect of resultRaw) {
                if (!(0, PodmanInspectImageRecord_1.isPodmanInspectImageRecord)(inspect)) {
                    throw new Error('Invalid image inspect json');
                }
                results.push((0, PodmanInspectImageRecord_1.normalizePodmanInspectImageRecord)(inspect));
            }
        }
        catch (err) {
            if (strict) {
                throw err;
            }
        }
        return results;
    }
    //#endregion
    //#region ListContainers Command
    async parseListContainersCommandOutput(options, output, strict) {
        const containers = new Array();
        try {
            const rawContainers = JSON.parse(output);
            rawContainers.forEach((rawContainer) => {
                var _a;
                try {
                    if (!(0, PodmanListContainerRecord_1.isPodmanListContainerRecord)(rawContainer)) {
                        throw new Error('Invalid container JSON');
                    }
                    const name = (_a = rawContainer.Names) === null || _a === void 0 ? void 0 : _a[0].trim();
                    const createdAt = dayjs_1.dayjs.unix(rawContainer.Created).toDate();
                    const ports = (rawContainer.Ports || []).map(p => {
                        return {
                            containerPort: p.container_port,
                            hostIp: p.host_ip || "127.0.0.1",
                            hostPort: p.host_port,
                            protocol: p.protocol,
                        };
                    });
                    containers.push({
                        id: rawContainer.Id,
                        image: (0, parseDockerLikeImageName_1.parseDockerLikeImageName)(rawContainer.Image),
                        name,
                        labels: rawContainer.Labels || {},
                        createdAt,
                        ports,
                        networks: rawContainer.Networks || [],
                        state: rawContainer.State,
                        status: rawContainer.Status,
                    });
                }
                catch (err) {
                    if (strict) {
                        throw err;
                    }
                }
            });
        }
        catch (err) {
            if (strict) {
                throw err;
            }
        }
        return containers;
    }
    //#endregion
    //#region PruneContainers Command
    parsePruneContainersCommandOutput(options, output, strict) {
        return Promise.resolve({
            containersDeleted: (0, asIds_1.asIds)(output),
        });
    }
    //#endregion
    //#region InspectContainers Command
    async parseInspectContainersCommandOutput(options, output, strict) {
        const results = new Array();
        try {
            const resultRaw = JSON.parse(output);
            if (!Array.isArray(resultRaw)) {
                throw new Error('Invalid container inspect json');
            }
            for (const inspect of resultRaw) {
                if (!(0, PodmanInspectContainerRecord_1.isPodmanInspectContainerRecord)(inspect)) {
                    throw new Error('Invalid container inspect json');
                }
                results.push((0, PodmanInspectContainerRecord_1.normalizePodmanInspectContainerRecord)(inspect));
            }
        }
        catch (err) {
            if (strict) {
                throw err;
            }
        }
        return results;
    }
    //#endregion
    //#region ListNetworks Command
    async parseListNetworksCommandOutput(options, output, strict) {
        // Podman networks are drastically different from Docker networks in terms of what details are available
        const results = new Array();
        try {
            const resultRaw = JSON.parse(output);
            if (!Array.isArray(resultRaw)) {
                throw new Error('Invalid network json');
            }
            for (const network of resultRaw) {
                if (!(0, PodmanListNetworkRecord_1.isPodmanListNetworkRecord)(network)) {
                    throw new Error('Invalid network json');
                }
                results.push({
                    name: network.name || network.Name || '',
                    labels: network.Labels || {},
                    createdAt: network.created ? new Date(network.created) : undefined,
                    internal: network.internal,
                    ipv6: network.ipv6_enabled,
                    driver: network.driver,
                    id: network.id,
                    scope: undefined, // Not available from Podman
                });
            }
        }
        catch (err) {
            if (strict) {
                throw err;
            }
        }
        return results;
    }
    //#endregion
    //#region PruneNetworks Command
    parsePruneNetworksCommandOutput(options, output, strict) {
        return Promise.resolve({
            networksDeleted: (0, asIds_1.asIds)(output),
        });
    }
    //#endregion
    //#region InspectNetworks Command
    async parseInspectNetworksCommandOutput(options, output, strict) {
        // Podman networks are drastically different from Docker networks in terms of what details are available
        const results = new Array();
        try {
            const resultRaw = JSON.parse(output);
            if (!Array.isArray(resultRaw)) {
                throw new Error('Invalid network inspect json');
            }
            for (const network of resultRaw) {
                if (!(0, PodmanInspectNetworkRecord_1.isPodmanInspectNetworkRecord)(network)) {
                    throw new Error('Invalid network inspect json');
                }
                results.push((0, PodmanInspectNetworkRecord_1.normalizePodmanInspectNetworkRecord)(network));
            }
        }
        catch (err) {
            if (strict) {
                throw err;
            }
        }
        return results;
    }
    //#endregion
    //#region ListVolumes Command
    async parseListVolumesCommandOutput(options, output, strict) {
        // Podman volume inspect is identical to volume list
        return this.parseInspectVolumesCommandOutput(options, output, strict);
    }
    //#endregion
    //#region PruneVolumes Command
    parsePruneVolumesCommandOutput(options, output, strict) {
        return Promise.resolve({
            volumesDeleted: (0, asIds_1.asIds)(output),
        });
    }
    //#endregion
    //#region InspectVolumes Command
    async parseInspectVolumesCommandOutput(options, output, strict) {
        const results = new Array();
        try {
            const resultRaw = JSON.parse(output);
            if (!Array.isArray(resultRaw)) {
                throw new Error('Invalid volume json');
            }
            for (const volume of resultRaw) {
                if (!(0, PodmanInspectVolumeRecord_1.isPodmanInspectVolumeRecord)(volume)) {
                    throw new Error('Invalid volume json');
                }
                results.push((0, PodmanInspectVolumeRecord_1.normalizePodmanInspectVolumeRecord)(volume));
            }
        }
        catch (err) {
            if (strict) {
                throw err;
            }
        }
        return results;
    }
}
exports.PodmanClient = PodmanClient;
/**
 * The ID of the Podman client
 */
PodmanClient.ClientId = 'com.microsoft.visualstudio.containers.podman';
//# sourceMappingURL=PodmanClient.js.map