"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See LICENSE in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShellStreamCommandRunnerFactory = void 0;
const stream = require("stream");
const CommandRunner_1 = require("../contracts/CommandRunner");
const AccumulatorStream_1 = require("../utils/AccumulatorStream");
const CancellationError_1 = require("../utils/CancellationError");
const spawnStreamAsync_1 = require("../utils/spawnStreamAsync");
/**
 * A {@link CommandRunnerFactory} that executes commands on a given shell and
 * manages access to the necessary stdio streams
 */
class ShellStreamCommandRunnerFactory {
    constructor(options) {
        this.options = options;
    }
    getCommandRunner() {
        return async (commandResponseLike) => {
            const commandResponse = await (0, CommandRunner_1.normalizeCommandResponseLike)(commandResponseLike);
            const { command, args } = this.getCommandAndArgs(commandResponse);
            throwIfCancellationRequested(this.options.cancellationToken);
            let result;
            let accumulator;
            try {
                if (commandResponse.parse) {
                    accumulator = new AccumulatorStream_1.AccumulatorStream();
                }
                // Determine the appropriate combination of streams that need to read from stdout
                let stdOutPipe = accumulator;
                if (accumulator && this.options.stdOutPipe) {
                    const stdOutPassThrough = new stream.PassThrough();
                    stdOutPassThrough.pipe(this.options.stdOutPipe);
                    stdOutPassThrough.pipe(accumulator);
                    stdOutPipe = stdOutPassThrough;
                }
                else if (this.options.stdOutPipe) {
                    stdOutPipe = this.options.stdOutPipe;
                }
                await (0, spawnStreamAsync_1.spawnStreamAsync)(command, args, { ...this.options, stdOutPipe: stdOutPipe });
                throwIfCancellationRequested(this.options.cancellationToken);
                if (accumulator && commandResponse.parse) {
                    const output = await accumulator.getString();
                    throwIfCancellationRequested(this.options.cancellationToken);
                    result = await commandResponse.parse(output, !!this.options.strict);
                }
                throwIfCancellationRequested(this.options.cancellationToken);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                return result;
            }
            finally {
                accumulator === null || accumulator === void 0 ? void 0 : accumulator.destroy();
            }
        };
    }
    getStreamingCommandRunner() {
        return this.streamingCommandRunner.bind(this);
    }
    async *streamingCommandRunner(commandResponseLike) {
        const commandResponse = await (0, CommandRunner_1.normalizeCommandResponseLike)(commandResponseLike);
        const { command, args } = this.getCommandAndArgs(commandResponse);
        throwIfCancellationRequested(this.options.cancellationToken);
        const dataStream = new stream.PassThrough();
        const innerGenerator = commandResponse.parseStream(dataStream, !!this.options.strict);
        // The process promise will be awaited only after the innerGenerator finishes
        const processPromise = (0, spawnStreamAsync_1.spawnStreamAsync)(command, args, { ...this.options, stdOutPipe: dataStream });
        for await (const element of innerGenerator) {
            yield element;
        }
        await processPromise;
    }
    getCommandAndArgs(commandResponse) {
        return commandResponse;
    }
}
exports.ShellStreamCommandRunnerFactory = ShellStreamCommandRunnerFactory;
function throwIfCancellationRequested(token) {
    if (token === null || token === void 0 ? void 0 : token.isCancellationRequested) {
        throw new CancellationError_1.CancellationError('Command cancelled', token);
    }
}
//# sourceMappingURL=shellStream.js.map