"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See LICENSE in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.spawnStreamAsync = exports.NoShell = exports.Cmd = exports.Bash = exports.Powershell = exports.Shell = void 0;
const child_process_1 = require("child_process");
const os = require("os");
const treeKill = require("tree-kill");
const vscode_1 = require("vscode");
const CancellationTokenLike_1 = require("../typings/CancellationTokenLike");
const CancellationError_1 = require("./CancellationError");
const ChildProcessError_1 = require("./ChildProcessError");
/**
 * A {@link Shell} class applies quoting rules for a specific shell.
 * Quoth the cmd.exe 'nevermore'.
 */
class Shell {
    static getShellOrDefault(shell) {
        if (shell) {
            return shell;
        }
        if (os.platform() === 'win32') {
            return new Cmd();
        }
        else {
            return new Bash();
        }
    }
    /**
     * Apply shell specific escaping rules to a Go Template string
     * @param arg The string to apply Go Template specific escaping rules for a given shell
     * @param quoting A {@link ShellQuotedString} that is properly escaped for Go Templates in the given shell
     */
    goTemplateQuotedString(arg, quoting) {
        return {
            value: arg,
            quoting,
        };
    }
    getShellOrDefault(shell) {
        return shell;
    }
}
exports.Shell = Shell;
/**
 * Quoting/escaping rules for Powershell shell
 */
class Powershell extends Shell {
    quote(args) {
        const escape = (value) => `\`${value}`;
        return args.map((quotedArg) => {
            // If it's a verbatim argument, return it as-is.
            // The overwhelming majority of arguments are `ShellQuotedString`, so
            // verbatim arguments will only show up if `withVerbatimArg` is used.
            if (typeof quotedArg === 'string') {
                return quotedArg;
            }
            switch (quotedArg.quoting) {
                case vscode_1.ShellQuoting.Escape:
                    return quotedArg.value.replace(/[ "'()]/g, escape);
                case vscode_1.ShellQuoting.Weak:
                    return `"${quotedArg.value.replace(/["]/g, escape)}"`;
                case vscode_1.ShellQuoting.Strong:
                    return `'${quotedArg.value.replace(/[']/g, escape)}'`;
            }
        });
    }
    goTemplateQuotedString(arg, quoting) {
        switch (quoting) {
            case vscode_1.ShellQuoting.Escape:
                return { value: arg, quoting };
            case vscode_1.ShellQuoting.Weak:
            case vscode_1.ShellQuoting.Strong:
                return {
                    value: arg.replace(/["]/g, (value) => `\\${value}`),
                    quoting,
                };
        }
    }
    getShellOrDefault(shell) {
        if (typeof shell !== 'string' && shell !== false) {
            return 'powershell.exe';
        }
        return shell;
    }
}
exports.Powershell = Powershell;
/**
 * Quoting/escaping rules for bash/zsh shell
 */
class Bash extends Shell {
    quote(args) {
        const escape = (value) => `\\${value}`;
        return args.map((quotedArg) => {
            // If it's a verbatim argument, return it as-is.
            // The overwhelming majority of arguments are `ShellQuotedString`, so
            // verbatim arguments will only show up if `withVerbatimArg` is used.
            if (typeof quotedArg === 'string') {
                return quotedArg;
            }
            switch (quotedArg.quoting) {
                case vscode_1.ShellQuoting.Escape:
                    return quotedArg.value.replace(/[ "']/g, escape);
                case vscode_1.ShellQuoting.Weak:
                    return `"${quotedArg.value.replace(/["]/g, escape)}"`;
                case vscode_1.ShellQuoting.Strong:
                    return `'${quotedArg.value.replace(/[']/g, escape)}'`;
            }
        });
    }
}
exports.Bash = Bash;
/**
 * Quoting/escaping rules for cmd shell
 */
class Cmd extends Shell {
    quote(args) {
        const escapeQuote = (value) => `\\${value}`;
        const escape = (value) => `^${value}`;
        return args.map((quotedArg) => {
            // If it's a verbatim argument, return it as-is.
            // The overwhelming majority of arguments are `ShellQuotedString`, so
            // verbatim arguments will only show up if `withVerbatimArg` is used.
            if (typeof quotedArg === 'string') {
                return quotedArg;
            }
            switch (quotedArg.quoting) {
                case vscode_1.ShellQuoting.Escape:
                    return quotedArg.value.replace(/[ "^&\\<>|]/g, escape);
                case vscode_1.ShellQuoting.Weak:
                    return quotedArg.value.replace(/[ "^&\\<>|]/g, escape);
                case vscode_1.ShellQuoting.Strong:
                    return `"${quotedArg.value.replace(/["]/g, escapeQuote)}"`;
            }
        });
    }
}
exports.Cmd = Cmd;
/**
 * Quoting/escaping rules for no shell
 */
class NoShell extends Shell {
    constructor(isWindows) {
        super();
        this.isWindows = typeof isWindows === 'boolean' ? isWindows : os.platform() === 'win32';
    }
    quote(args) {
        const windowsEscape = (value) => `\\${value}`;
        return args.map((quotedArg) => {
            // If it's a verbatim argument, return it as-is.
            // The overwhelming majority of arguments are `ShellQuotedString`, so
            // verbatim arguments will only show up if `withVerbatimArg` is used.
            if (typeof quotedArg === 'string') {
                return quotedArg;
            }
            // Windows requires special quoting behavior even when running without a shell
            // to allow us to use windowsVerbatimArguments: true
            if (this.isWindows) {
                switch (quotedArg.quoting) {
                    case vscode_1.ShellQuoting.Weak:
                    case vscode_1.ShellQuoting.Strong:
                        return `"${quotedArg.value.replace(/["]/g, windowsEscape)}"`;
                    default:
                        return quotedArg.value;
                }
            }
            return quotedArg.value;
        });
    }
    getShellOrDefault(shell) {
        return false;
    }
}
exports.NoShell = NoShell;
async function spawnStreamAsync(command, args, options) {
    var _a, _b, _c, _d;
    const cancellationToken = options.cancellationToken || CancellationTokenLike_1.CancellationTokenLike.None;
    // Force PowerShell as the default on Windows, but use the system default on
    // *nix
    const shell = (_b = (_a = options.shellProvider) === null || _a === void 0 ? void 0 : _a.getShellOrDefault(options.shell)) !== null && _b !== void 0 ? _b : options.shell;
    // If there is a shell provider, apply its quoting, otherwise just flatten arguments into strings
    const normalizedArgs = (_d = (_c = options.shellProvider) === null || _c === void 0 ? void 0 : _c.quote(args)) !== null && _d !== void 0 ? _d : args.map(arg => typeof arg === 'string' ? arg : arg.value);
    if (cancellationToken.isCancellationRequested) {
        throw new CancellationError_1.CancellationError('Command cancelled', cancellationToken);
    }
    if (options.onCommand) {
        options.onCommand([command, ...normalizedArgs].join(' '));
    }
    const childProcess = (0, child_process_1.spawn)(command, normalizedArgs, {
        ...options,
        shell,
        // Ignore stdio streams if not needed to avoid backpressure issues
        stdio: [
            options.stdInPipe ? 'pipe' : 'ignore',
            options.stdOutPipe ? 'pipe' : 'ignore',
            options.stdErrPipe ? 'pipe' : 'ignore',
        ],
    });
    if (options.stdInPipe && childProcess.stdin) {
        options.stdInPipe.pipe(childProcess.stdin);
    }
    if (options.stdOutPipe && childProcess.stdout) {
        childProcess.stdout.pipe(options.stdOutPipe);
    }
    if (options.stdErrPipe && childProcess.stderr) {
        childProcess.stderr.pipe(options.stdErrPipe);
    }
    return new Promise((resolve, reject) => {
        const disposable = cancellationToken.onCancellationRequested(() => {
            var _a, _b;
            disposable.dispose();
            (_a = options.stdOutPipe) === null || _a === void 0 ? void 0 : _a.end();
            (_b = options.stdErrPipe) === null || _b === void 0 ? void 0 : _b.end();
            childProcess.removeAllListeners();
            if (childProcess.pid) {
                treeKill(childProcess.pid);
            }
            reject(new CancellationError_1.CancellationError('Command cancelled', cancellationToken));
        });
        // Reject the promise on an error event
        childProcess.on('error', (err) => {
            disposable.dispose();
            reject(err);
        });
        // Complete the promise when the process exits
        childProcess.on('exit', (code, signal) => {
            disposable.dispose();
            if (code === 0) {
                resolve();
            }
            else if (signal) {
                reject(new ChildProcessError_1.ChildProcessError(`Process exited due to signal ${signal}`, code, signal));
            }
            else {
                reject(new ChildProcessError_1.ChildProcessError(`Process exited with code ${code}`, code, signal));
            }
        });
    });
}
exports.spawnStreamAsync = spawnStreamAsync;
//# sourceMappingURL=spawnStreamAsync.js.map