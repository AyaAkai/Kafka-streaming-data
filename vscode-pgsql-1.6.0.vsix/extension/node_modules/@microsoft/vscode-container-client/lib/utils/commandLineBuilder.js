"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See LICENSE in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.innerQuoted = exports.escaped = exports.quoted = exports.withVerbatimArg = exports.withNamedArg = exports.withFlagArg = exports.withQuotedArg = exports.withArg = exports.composeArgs = void 0;
const vscode_1 = require("vscode");
const toArray_1 = require("./toArray");
/**
 * Chain multiple command line argument generator functions
 * @param cmdLineArgFns Command line argument methods to compose into chained calls
 * @returns A function that takes an optional starting CommandLineArgs record
 */
function composeArgs(...cmdLineArgFns) {
    return (cmdLineArgs = []) => {
        return cmdLineArgFns.reduce((commandLineArgs, cmdLineArgsFn) => cmdLineArgsFn(commandLineArgs), cmdLineArgs || []); // A bug in the Inlay Hints feature is fixed by this redundant `as unknown as CommandLineArgs` casting
    };
}
exports.composeArgs = composeArgs;
/**
 * Functional method for adding additional raw arguments to an existing list of
 * arguments.
 * @param args Raw arguments to add to the CommandLineArguments records
 * @returns A function that takes an optional array of CommandLineArguments and appends the provided arguments
 */
function withArg(...args) {
    return (cmdLineArgs = []) => {
        return args.map(escaped).reduce((allArgs, arg) => {
            if (arg) {
                return [...allArgs, arg];
            }
            return allArgs;
        }, cmdLineArgs);
    };
}
exports.withArg = withArg;
/**
 * Functional method for adding additional quoted arguments to an existing
 * list of arguments.
 * @param args Raw arguments to add to the CommandLineArguments records
 * @returns A function that takes an optional array of CommandLineArguments and appends the provided arguments
 */
function withQuotedArg(...args) {
    return (cmdLineArgs = []) => {
        return args.map(quoted).reduce((allArgs, arg) => {
            if (arg) {
                return [...allArgs, arg];
            }
            return allArgs;
        }, cmdLineArgs);
    };
}
exports.withQuotedArg = withQuotedArg;
/**
 * Functional method for adding a flag argument (--name=value) to an existing list
 * of arguments.
 * @param name The name of the flag argument
 * @param value The value to set for the flag argument
 * @returns A function that takes an optional array of CommandLineArguments and appends the specified flag argument
 */
function withFlagArg(name, value) {
    return (cmdLineArgs = []) => {
        if (value) {
            return withArg(name)(cmdLineArgs);
        }
        return cmdLineArgs;
    };
}
exports.withFlagArg = withFlagArg;
/**
 * Functional method for assigning an array style argument (multiple instances
 * of the argument are treated as an appended list)
 * @param name The name of the argument
 * @param args The values to set for the argument
 * @returns A function that takes an optional array of CommandLineArguments and appends an array style argument
 */
function withNamedArg(name, args, { assignValue = false, shouldQuote = true } = {}) {
    return (cmdLineArgs = []) => {
        return (0, toArray_1.toArray)(args)
            .reduce((allArgs, arg) => {
            if (arg) {
                const normalizedArg = shouldQuote ? quoted(arg) : escaped(arg);
                if (assignValue) {
                    return withArg(`${name}=${normalizedArg === null || normalizedArg === void 0 ? void 0 : normalizedArg.value}`)(allArgs);
                }
                return withArg(name, normalizedArg)(allArgs);
            }
            return allArgs;
        }, cmdLineArgs);
    };
}
exports.withNamedArg = withNamedArg;
/**
 * Functional method for adding additional verbatim arguments to an existing list of
 * arguments. They will not be quoted nor escaped.
 * @param args Raw arguments to add to the CommandLineArguments records
 * @returns A function that takes an optional array of CommandLineArguments and appends the provided arguments
 * @deprecated {@link withArg} should be used instead in almost all cases
 */
function withVerbatimArg(...args) {
    return (cmdLineArgs = []) => {
        return args.reduce((allArgs, arg) => {
            if (arg) {
                return [...allArgs, arg];
            }
            return allArgs;
        }, cmdLineArgs);
    };
}
exports.withVerbatimArg = withVerbatimArg;
/**
 * Convert a value to a ShellQuotedString record
 * @param value The value to potentially wrap as a ShellQuotedString
 * @returns A new ShellQuotedString for the given value or undefined if value is empty
 */
function quoted(value) {
    if (value) {
        if (typeof value === 'string') {
            return {
                value: value,
                quoting: vscode_1.ShellQuoting.Strong,
            };
        }
        else {
            return value;
        }
    }
    return undefined;
}
exports.quoted = quoted;
/**
 * Convert a value to an escaped ShellQuotedString record
 * @param value The value to potentially wrap as an escaped ShellQuotedString
 * @returns a new ShellQuotedString with quoting set to Escape or undefined if the value is empty
 */
function escaped(value) {
    if (value) {
        if (typeof value === 'string') {
            return {
                value,
                quoting: vscode_1.ShellQuoting.Escape,
            };
        }
        else {
            return value;
        }
    }
    return undefined;
}
exports.escaped = escaped;
/**
 * Convert a value to a weak ShellQuotedString record
 * @param value The value to potentially wrap a a weak ShellQuotedString
 * @returns A new ShellQuotedString with quoting set to Weak or undefined if the value is empty
 */
function innerQuoted(value) {
    if (value) {
        if (typeof value === 'string') {
            return {
                value,
                quoting: vscode_1.ShellQuoting.Weak,
            };
        }
        else {
            return {
                ...value,
                quoting: value.quoting === vscode_1.ShellQuoting.Escape ? vscode_1.ShellQuoting.Weak : value.quoting,
            };
        }
    }
    return undefined;
}
exports.innerQuoted = innerQuoted;
//# sourceMappingURL=commandLineBuilder.js.map